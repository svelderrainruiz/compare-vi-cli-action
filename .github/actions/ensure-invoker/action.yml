name: ensure-invoker
description: Start/stop a one-shot invoker per job with sentinel/markers
inputs:
  mode:
    description: start or stop
    required: true
  results-dir:
    description: Base results directory
    required: false
    default: tests/results
  category:
    description: Optional category subfolder appended to results-dir
    required: false
  require-invoker:
    description: When false, skip spawning the invoker even on Windows
    required: false
    default: 'true'
  timeout-seconds:
    description: Wait time for ready/stop markers
    required: false
    default: '60'
  retries:
    description: Attempts to (re)start if not ready
    required: false
    default: '3'
  retry-delay-seconds:
    description: Delay between retries
    required: false
    default: '7'
outputs:
  pipe-name:
    description: Computed pipe name for this job
    value: ${{ steps.compute.outputs.pipe_name }}
  sentinel-path:
    description: Sentinel path for this job
    value: ${{ steps.compute.outputs.sentinel }}
  ready:
    description: "'true' if invoker reached READY"
    value: ${{ steps.start.outputs.ready }}
  reason:
    description: "Reason when not ready (timeout|error|ready)"
    value: ${{ steps.start.outputs.reason }}
runs:
  using: composite
  steps:
    - id: compute
      shell: pwsh
      run: |
        $base = '${{ inputs.results-dir }}'
        $cat  = '${{ inputs.category }}'
        if ($cat) { $base = Join-Path $base $cat }
        $pipe = "lvci.invoker.$env:GITHUB_RUN_ID.$env:GITHUB_JOB.$env:GITHUB_RUN_ATTEMPT"
        $sent = Join-Path $env:RUNNER_TEMP "invoker/$($env:GITHUB_RUN_ID).$($env:GITHUB_JOB).sentinel"
        New-Item -ItemType Directory -Path (Split-Path -Parent $sent) -Force | Out-Null
        "pipe_name=$pipe" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        "sentinel=$sent"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        "results=$base"    | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

    - name: Start invoker (Windows only)
      id: start
      if: ${{ inputs.mode == 'start' && runner.os == 'Windows' && inputs.require-invoker != 'false' }}
      shell: pwsh
      run: |
        $results = '${{ steps.compute.outputs.results }}'
        if (-not (Test-Path -LiteralPath $results)) { New-Item -ItemType Directory -Path $results -Force | Out-Null }
        $invdir  = Join-Path $results '_invoker'
        if (-not (Test-Path -LiteralPath $invdir)) { New-Item -ItemType Directory -Path $invdir -Force | Out-Null }
        $pipe    = '${{ steps.compute.outputs.pipe_name }}'
        $sent    = '${{ steps.compute.outputs.sentinel }}'
        $ready   = Join-Path $results '_invoker/ready.json'
        $stopped = Join-Path $results '_invoker/stopped.json'
        $boot    = Join-Path $results '_invoker/boot.log'
        if (Test-Path -LiteralPath $ready) { Remove-Item -LiteralPath $ready -Force -ErrorAction SilentlyContinue }
        if (Test-Path -LiteralPath $stopped) { Remove-Item -LiteralPath $stopped -Force -ErrorAction SilentlyContinue }
        if (-not (Test-Path -LiteralPath $sent)) { New-Item -ItemType File -Path $sent -Force | Out-Null }
        $attempts = [int]'${{ inputs.retries }}'
        $delay    = [int]'${{ inputs.retry-delay-seconds }}'
        $to       = [int]'${{ inputs.timeout-seconds }}'
        $ok = $false; $err=''
        # Resolve PowerShell 7 executable explicitly (service context may lack PATH)
        $psExe = $null
        try { $cmd = Get-Command pwsh -ErrorAction SilentlyContinue; if ($cmd -and $cmd.Source) { $psExe = $cmd.Source } } catch {}
        if (-not $psExe -and $PSHome) { $psExe = Join-Path $PSHome 'pwsh.exe' }
        if (-not (Test-Path -LiteralPath $psExe -PathType Leaf)) { $psExe = 'pwsh' }

        for ($i=1; $i -le $attempts; $i++) {
          $ts = (Get-Date -Format o)
          try {
            $args = @('-ExecutionPolicy','Bypass','-NoLogo','-NoProfile','-File','tools/RunnerInvoker/Start-RunnerInvoker.ps1','-PipeName',"$pipe",'-SentinelPath',"$sent",'-ResultsDir',"$results")
            $envMap = @{}
            foreach ($k in @('LV_NOTICE_DIR','LV_SUPPRESS_UI','LV_NO_ACTIVATE','LV_CURSOR_RESTORE','LV_IDLE_WAIT_SECONDS','LV_IDLE_MAX_WAIT_SECONDS')) {
              $v = [Environment]::GetEnvironmentVariable($k)
              if ($v -and $v -ne '') { $envMap[$k] = $v }
            }
            $wd = if ($env:GITHUB_WORKSPACE) { $env:GITHUB_WORKSPACE } else { (Get-Location).Path }
            $p = Start-Process -FilePath $psExe -ArgumentList $args -WindowStyle Hidden -PassThru -WorkingDirectory $wd -Environment $envMap
            Write-Host "Started invoker attempt #$i pid=$($p.Id) pipe=$pipe"
            "[$ts] attempt#$i spawn pid=$($p.Id) pipe=$pipe" | Out-File -FilePath $boot -Append -Encoding utf8
          } catch {
            # Fallback: create a small wrapper script that sets env vars inline, then starts the invoker
            $err = $_.Exception.Message
            Write-Host "::warning::Failed to spawn invoker on attempt #$i (env injection): $err"
            try {
              $wrapper = Join-Path $env:RUNNER_TEMP ("invoker-wrapper-{0}.ps1" -f ([Guid]::NewGuid().ToString('N')))
              $lines = @()
              foreach ($pair in $envMap.GetEnumerator()) {
                $val = ($pair.Value -replace "'", "''")
                $lines += ("Set-Item -Path 'Env:{0}' -Value '{1}'" -f $pair.Key, $val)
              }
              $startPath = Join-Path $wd 'tools/RunnerInvoker/Start-RunnerInvoker.ps1'
              $lines += ("& '{0}' -PipeName '{1}' -SentinelPath '{2}' -ResultsDir '{3}'" -f $startPath, $pipe, $sent, $results)
              ($lines -join "`n") | Out-File -FilePath $wrapper -Encoding utf8
              $p = Start-Process -FilePath $psExe -ArgumentList @('-NoLogo','-NoProfile','-File', $wrapper) -WindowStyle Hidden -PassThru -WorkingDirectory $wd
              Write-Host "Started invoker (fallback) attempt #$i pid=$($p.Id) pipe=$pipe"
              "[$ts] attempt#$i spawn (fallback) pid=$($p.Id) pipe=$pipe" | Out-File -FilePath $boot -Append -Encoding utf8
            } catch {
              $err = $_.Exception.Message
              Write-Host "::warning::Fallback spawn failed on attempt #$i: $err"
              "[$ts] attempt#$i spawn error: $err" | Out-File -FilePath $boot -Append -Encoding utf8
            }
          }
          $sw = [Diagnostics.Stopwatch]::StartNew()
          while ($sw.Elapsed.TotalSeconds -lt $to) { if (Test-Path -LiteralPath $ready) { $ok = $true; break }; Start-Sleep -Milliseconds 300 }
          if ($ok) { "[$(Get-Date -Format o)] attempt#$i ready observed" | Out-File -FilePath $boot -Append -Encoding utf8; break }
          if ($i -lt $attempts) {
            try { if ($p -and -not $p.HasExited) { $p | Stop-Process -Force -ErrorAction SilentlyContinue } } catch {}
            "[$(Get-Date -Format o)] attempt#$i timed out after $to s; retrying in $delay s" | Out-File -FilePath $boot -Append -Encoding utf8
            Start-Sleep -Seconds $delay
          }
        }
        if ($ok) {
          "ready=true"  | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "reason=ready"| Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        } else {
          "[$(Get-Date -Format o)] all attempts exhausted; lastError=$err" | Out-File -FilePath $boot -Append -Encoding utf8
          Write-Host "::error::Invoker not ready after ${to} s (attempts=$attempts). LastError=$err"
          "ready=false"        | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "reason=timeout"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          exit 1
        }

    - name: Invoker ping (Windows only)
      if: ${{ inputs.mode == 'start' && runner.os == 'Windows' && inputs.require-invoker != 'false' && steps.start.outputs.ready == 'true' }}
      shell: pwsh
      run: |
        $args = @(
          '-PipeName','${{ steps.compute.outputs.pipe_name }}',
          '-ResultsDir','${{ steps.compute.outputs.results }}',
          '-TimeoutSeconds','15',
          '-Retries','5',
          '-RetryDelaySeconds','2'
        )
        pwsh -File tools/RunnerInvoker/Wait-InvokerReady.ps1 @args

    - name: Stop invoker (Windows only)
      if: ${{ inputs.mode == 'stop' && runner.os == 'Windows' && inputs.require-invoker != 'false' }}
      shell: pwsh
      run: |
        $results = '${{ steps.compute.outputs.results }}'
        $sent    = '${{ steps.compute.outputs.sentinel }}'
        $ready   = Join-Path $results '_invoker/ready.json'
        $stopped = Join-Path $results '_invoker/stopped.json'
        if (Test-Path -LiteralPath $sent) { Remove-Item -LiteralPath $sent -Force -ErrorAction SilentlyContinue }
        $to = [int]'${{ inputs.timeout-seconds }}'
        $deadline = (Get-Date).AddSeconds([math]::Max(1,$to))
        while ((Get-Date) -lt $deadline) {
          if (Test-Path -LiteralPath $stopped) { break }
          Start-Sleep -Milliseconds 300
        }

        $stopPayload = $null
        $fallbackReason = $null
        if (Test-Path -LiteralPath $stopped) {
          try {
            $stopPayload = Get-Content -LiteralPath $stopped -Raw -Encoding UTF8 | ConvertFrom-Json -Depth 8
          } catch {
            $fallbackReason = 'stop-payload-parse-error: ' + $_.Exception.Message
            $stopPayload = $null
          }
        } else {
          $fallbackReason = 'stop-marker-missing'
        }

        $summaryLines = @('### Invoker stop status','',('- Sentinel path: `{0}`' -f $sent))
        $fallbackUsed = $false
        $trackerFinal = $null
        $trackerError = $null
        $trackerBlock = $null
        $trackerNotice = $null
        $trackerContextResolved = $null
        $repoRoot = if ($env:GITHUB_WORKSPACE) { $env:GITHUB_WORKSPACE } else { (Get-Location).Path }
        $trackerModulePath = $null
        if ($repoRoot) {
          $candidate = Join-Path $repoRoot 'tools/LabVIEWPidTracker.psm1'
          if (Test-Path -LiteralPath $candidate -PathType Leaf) { $trackerModulePath = $candidate }
        }
        if (-not $trackerModulePath) {
          $candidate = Join-Path (Get-Location).Path 'tools/LabVIEWPidTracker.psm1'
          if (Test-Path -LiteralPath $candidate -PathType Leaf) { $trackerModulePath = $candidate }
        }

        if (-not $stopPayload) {
          $fallbackUsed = $true
          $reasonText = if ($fallbackReason) { $fallbackReason } else { 'stop-payload-unavailable' }
          Write-Host ("::warning::Invoker stop payload unavailable ({0}); attempting tracker fallback." -f $reasonText)
          $summaryLines += ('- Fallback invoked (`{0}`).' -f $reasonText)

          $readyPayload = $null
          if (Test-Path -LiteralPath $ready) {
            try { $readyPayload = Get-Content -LiteralPath $ready -Raw -Encoding UTF8 | ConvertFrom-Json -Depth 8 } catch {}
          }

          if ($readyPayload -and $readyPayload.PSObject.Properties['labviewPidTracker']) {
            $trackerBlock = $readyPayload.labviewPidTracker
          } elseif (Test-Path -LiteralPath (Join-Path $results '_invoker/labview-pid.json')) {
            $trackerBlock = [pscustomobject]@{ path = (Join-Path $results '_invoker/labview-pid.json') }
          }

          $trackerPath = $null
          if ($trackerBlock -and $trackerBlock.PSObject.Properties['path']) {
            try { $trackerPath = [string]$trackerBlock.path } catch { $trackerPath = $null }
          }

          $trackerContextPath = $null
          if ($trackerBlock -and $trackerBlock.PSObject.Properties['contextPath']) {
            try { $trackerContextPath = [string]$trackerBlock.contextPath } catch { $trackerContextPath = $null }
          }

          $contextObject = $null
          if ($trackerContextPath -and (Test-Path -LiteralPath $trackerContextPath -PathType Leaf)) {
            try { $contextObject = Get-Content -LiteralPath $trackerContextPath -Raw -Encoding UTF8 | ConvertFrom-Json -Depth 8 } catch { $contextObject = $null }
          }
          if (-not $contextObject) {
            $contextObject = [ordered]@{
              stage        = 'ensure-invoker:stop-fallback'
              sentinelPath = $sent
              reason       = $reasonText
            }
          }

          if (-not $trackerModulePath) {
            $trackerNotice = 'LabVIEW PID tracker module unavailable for fallback finalization'
          }

          if ($trackerModulePath -and $trackerPath -and (Test-Path -LiteralPath $trackerPath -PathType Leaf)) {
            try {
              Import-Module $trackerModulePath -Force -ErrorAction Stop | Out-Null
              if (Get-Command -Name Resolve-LabVIEWPidContext -ErrorAction SilentlyContinue) {
                try { $trackerContextResolved = Resolve-LabVIEWPidContext -Input $contextObject } catch {}
                if (-not $trackerContextResolved) { $trackerContextResolved = $contextObject }
              }
              $stopArgs = @{ TrackerPath = $trackerPath; Source = 'ensure-invoker:stop' }
              if ($trackerBlock -and $trackerBlock.PSObject.Properties['initial'] -and $trackerBlock.initial -and $trackerBlock.initial.PSObject.Properties['Pid']) {
                try { $stopArgs['Pid'] = [int]$trackerBlock.initial.Pid } catch {}
              }
              if ($trackerContextResolved) { $stopArgs['Context'] = $trackerContextResolved }
              else { $stopArgs['Context'] = $contextObject }
              try {
                $trackerFinal = Stop-LabVIEWPidTracker @stopArgs
              } catch {
                $trackerError = $_.Exception.Message
                $trackerFinal = $null
              }
            } catch {
              $trackerError = $_.Exception.Message
            }
          } elseif (-not $trackerNotice) {
            $trackerNotice = 'Tracker path unavailable for fallback'
          }

          $stopPayload = [ordered]@{
            schema   = 'invoker-stopped/v1'
            at       = (Get-Date).ToUniversalTime().ToString('o')
            fallback = $true
          }
          $pidValue = $null
          if ($readyPayload -and $readyPayload.PSObject.Properties['pid']) {
            try { $pidValue = [int]$readyPayload.pid } catch { $pidValue = $null }
          }
          if ($pidValue) { $stopPayload['pid'] = $pidValue }
          if ($sent) { $stopPayload['sentinelPath'] = $sent }

          if ($trackerBlock -or $trackerFinal) {
            $trackerPayload = [ordered]@{ enabled = $true }
            if ($trackerBlock -and $trackerBlock.PSObject.Properties['path']) { $trackerPayload['path'] = $trackerPath }
            if ($trackerBlock -and $trackerBlock.PSObject.Properties['contextPath']) { $trackerPayload['contextPath'] = $trackerContextPath }
            if ($trackerBlock -and $trackerBlock.PSObject.Properties['initial']) { $trackerPayload['initial'] = $trackerBlock.initial }
            if ($trackerFinal) { $trackerPayload['final'] = $trackerFinal }
            elseif ($trackerContextResolved) { $trackerPayload['finalContext'] = $trackerContextResolved }
            elseif ($contextObject) { $trackerPayload['finalContext'] = $contextObject }
            if ($trackerError) { $trackerPayload['error'] = $trackerError }
            $stopPayload['labviewPidTracker'] = [pscustomobject]$trackerPayload
          } elseif ($trackerError) {
            $stopPayload['labviewPidTrackerError'] = $trackerError
          }

          try {
            $stopDir = Split-Path -Parent $stopped
            if ($stopDir -and -not (Test-Path -LiteralPath $stopDir -PathType Container)) {
              New-Item -ItemType Directory -Path $stopDir -Force | Out-Null
            }
            [pscustomobject]$stopPayload | ConvertTo-Json -Depth 8 | Set-Content -LiteralPath $stopped -Encoding UTF8
          } catch {
            Write-Host ("::warning::Failed to persist fallback invoker stop payload: {0}" -f $_.Exception.Message)
          }

          $stopPayload = [pscustomobject]$stopPayload
        } else {
          $summaryLines += '- Stop payload observed without fallback.'
        }

        if (-not $stopPayload) {
          Write-Host '::warning::Invoker stop payload still unavailable after fallback.'
          $summaryLines += '- Stop payload unavailable after fallback.'
        } else {
          if ($stopPayload.PSObject.Properties['labviewPidTracker']) {
            $trackerBlock = $stopPayload.labviewPidTracker
            if ($trackerBlock -and $trackerBlock.PSObject.Properties['final']) {
              $final = $trackerBlock.final
              $stage = $null
              if ($final.PSObject.Properties['Context'] -and $final.Context -and $final.Context.PSObject.Properties['stage']) {
                try { $stage = [string]$final.Context.stage } catch { $stage = $null }
              }
              if (-not $stage -and $final.PSObject.Properties['context'] -and $final.context -and $final.context.PSObject.Properties['stage']) {
                try { $stage = [string]$final.context.stage } catch { $stage = $null }
              }
              if (-not $stage -and $trackerBlock.PSObject.Properties['finalContext'] -and $trackerBlock.finalContext -and $trackerBlock.finalContext.PSObject.Properties['stage']) {
                try { $stage = [string]$trackerBlock.finalContext.stage } catch { $stage = $null }
              }
              if ($stage) {
                Write-Host ("Invoker LabVIEW PID tracker finalized with stage '{0}'." -f $stage)
                $summaryLines += ('- Tracker stage: `{0}`' -f $stage)
              }
              if ($final.PSObject.Properties['Running']) {
                try {
                  if ([bool]$final.Running) {
                    Write-Host '::warning::LabVIEW PID tracker reports LabVIEW.exe still running after invoker stop.'
                    $summaryLines += '- Tracker reports LabVIEW.exe still running.'
                  }
                } catch {}
              }
            }
            elseif ($trackerBlock -and $trackerBlock.PSObject.Properties['finalContext']) {
              $ctx = $trackerBlock.finalContext
              $stage = $null
              if ($ctx -and $ctx.PSObject.Properties['stage']) {
                try { $stage = [string]$ctx.stage } catch { $stage = $null }
              }
              if ($stage) {
                Write-Host ("Invoker LabVIEW PID tracker fallback context stage '{0}'." -f $stage)
                $summaryLines += ('- Tracker fallback stage: `{0}`' -f $stage)
              }
            }
            if ($trackerBlock -and $trackerBlock.PSObject.Properties['error']) {
              $summaryLines += ('- Tracker error: {0}' -f $trackerBlock.error)
            }
          } elseif ($trackerError) {
            Write-Host ("::warning::LabVIEW PID tracker fallback error: {0}" -f $trackerError)
            $summaryLines += ('- Tracker fallback error: {0}' -f $trackerError)
          } elseif ($trackerNotice) {
            Write-Host ("LabVIEW PID tracker fallback notice: {0}" -f $trackerNotice)
            $summaryLines += ('- Tracker fallback notice: {0}' -f $trackerNotice)
          }
        }

        if ($env:GITHUB_STEP_SUMMARY -and $summaryLines.Count -gt 0) {
          try {
            ($summaryLines -join "`n") | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          } catch {}
        }

    - name: No-op on non-Windows
      if: ${{ runner.os != 'Windows' }}
      shell: bash
      run: echo ensure-invoker non-Windows runner, skipping
