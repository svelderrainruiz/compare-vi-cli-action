name: Validate

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main]
  merge_group:
    branches: [main]
  workflow_dispatch:
    inputs:
      summary-verbose:
        description: 'Emit verbose fixture summary (sets SUMMARY_VERBOSE=true)'
        required: false
        default: 'false'
      sample_id:
        description: 'Sampling correlation id (prevents cancels)'
        required: false
        type: string

concurrency:
  group: ${{ github.workflow }}-${{ (github.event_name == 'pull_request' && github.event.pull_request.number) || github.event.inputs.sample_id || github.ref }}
  cancel-in-progress: true

jobs:
  smoke-gate:
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.determine.outputs.skip }}
    steps:
      - name: Determine skip for smoke branches
        id: determine
        shell: pwsh
        env:
          EVENT_NAME: ${{ github.event_name }}
          HEAD_REF: ${{ github.head_ref }}
        run: |
          $isSmoke = $false
          if ($env:EVENT_NAME -eq 'pull_request' -and $env:HEAD_REF -and $env:HEAD_REF.StartsWith('smoke/')) {
            $isSmoke = $true
          }
          $value = if ($isSmoke) { 'true' } else { 'false' }
          "skip=$value" | Out-File -FilePath $Env:GITHUB_OUTPUT -Encoding utf8 -Append

  lint:
    needs: smoke-gate
    if: needs.smoke-gate.outputs.skip != 'true'
    environment:
      name: validation
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v5
    - name: Check PR mergeability
      if: ${{ github.event_name == 'pull_request' }}
      shell: pwsh
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        ./tools/Check-PRMergeable.ps1 -Number ${{ github.event.pull_request.number }} -FailOnConflict
    - name: Wire Probe (J1)
      if: '${{ vars.WIRE_PROBES != ''0'' }}'
      uses: ./.github/actions/wire-probe
      with:
        phase: J1
        results-dir: tests/results
    - name: Wire Probe (J2)
      if: '${{ vars.WIRE_PROBES != ''0'' }}'
      uses: ./.github/actions/wire-probe
      with:
        phase: J2
        results-dir: tests/results
    - name: Setup Node with cache
      uses: actions/setup-node@v5
      with:
        node-version: '20'
        cache: 'npm'

    - name: CLI lints
      uses: ./.github/actions/cli-lints
      with:
        enforce: ${{ github.ref_name == 'main' || github.base_ref == 'main' }}
        linkcheck: 'true'
        actionlint-version: '1.7.7'
        relaxed-path: 'docs/releases/**/*.md'

    - name: Guard tracked build artifacts (enforced)
      shell: pwsh
      run: |
        # Optional allowlist via env ALLOWLIST_TRACKED_ARTIFACTS (semicolon-separated globs)
        # and/or file-based allowlist at .ci/build-artifacts-allow.txt
        pwsh -File tools/Check-TrackedBuildArtifacts.ps1 -AllowListPath '.ci/build-artifacts-allow.txt'

    - name: Surface build artifacts allowlist (if any)
      shell: pwsh
      run: |
        $path = '.ci/build-artifacts-allow.txt'
        if (Test-Path -LiteralPath $path -PathType Leaf) {
          $lines = Get-Content -LiteralPath $path | Where-Object { $_ -and -not ($_.Trim().StartsWith('#')) } | ForEach-Object { $_.Trim() }
          if ($lines.Count -gt 0 -and $env:GITHUB_STEP_SUMMARY) {
            $out = @('### Build Artifacts Allowlist','')
            foreach($l in $lines){ $out += ('- ' + $l) }
            $out -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          }
        }

    - name: Build artifacts guard — ad-hoc allowlist usage
      shell: pwsh
      run: |
        if ($env:GITHUB_STEP_SUMMARY) {
          $msg = @(
            '### Build Artifacts Guard — Ad-hoc Allowlist',
            '',
            '- To permit specific tracked paths temporarily, set ALLOWLIST_TRACKED_ARTIFACTS to a semicolon-separated list of globs.',
            "- Example: ``ALLOWLIST_TRACKED_ARTIFACTS='src/Legacy/**/bin/**;src/Legacy/**/obj/**'``",
            '- Prefer using .ci/build-artifacts-allow.txt for committed, reviewable exceptions.'
          ) -join "`n"
          $msg | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
        }

    - name: Derive environment snapshot
      shell: bash
      run: |
        set -euo pipefail
        node tools/npm/run-script.mjs --silent derive:env > derived-env.json
        mkdir -p tests/results/_agent
        cp derived-env.json tests/results/_agent/derived-env.json
        if [ -n "${GITHUB_STEP_SUMMARY:-}" ]; then
          {
            echo '### Derived Environment';
            echo '```json';
            cat derived-env.json;
            echo '```';
          } >> "$GITHUB_STEP_SUMMARY"
        fi

    - name: PrePush local gates (includes watcher schema validation)
      shell: pwsh
      run: |
        pwsh -File tools/PrePush-Checks.ps1

    - name: Policy guard (branch protection)
      shell: pwsh
      env:
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
      run: |
        node tools/npm/run-script.mjs priority:policy

    - name: Lint unanchored dot-sourcing (non-blocking)
      shell: pwsh
      continue-on-error: true
      run: |
        pwsh -File tools/Lint-DotSourcing.ps1 -WarnOnly

    - name: Lint inline-if in format (-f)
      shell: pwsh
      run: pwsh -File tools/Lint-InlineIfInFormat.ps1

    - name: Emit tool versions
      if: always()
      shell: bash
      run: |
        {
          echo '### Tool Versions'
          echo "- actionlint: $(./bin/actionlint -version || echo 'n/a')"
          echo "- node: $(node -v || echo 'n/a')"
          echo "- npm: $(npm -v || echo 'n/a')"
          echo "- markdownlint: $(markdownlint --version || echo 'n/a')"
        } >> "$GITHUB_STEP_SUMMARY"

    - name: Workflow drift check (ruamel updater — notice on develop)
      if: github.ref_name == 'develop' || github.base_ref == 'develop'
      shell: pwsh
      continue-on-error: true
      run: |
        python -m pip install --user ruamel.yaml
        python tools/workflows/update_workflows.py --check \
          .github/workflows/pester-selfhosted.yml \
          .github/workflows/fixture-drift.yml \
          .github/workflows/ci-orchestrated.yml \
          .github/workflows/pester-integration-on-label.yml \
          .github/workflows/smoke.yml \
          .github/workflows/compare-artifacts.yml
        if ($LASTEXITCODE -eq 3) { Write-Host '::notice::Workflow drift detected (develop). See ruamel updater output.' }

    - name: Workflow drift check (ruamel updater — enforced on main)
      if: github.ref_name == 'main' || github.base_ref == 'main'
      shell: pwsh
      run: |
        python -m pip install --user ruamel.yaml
        python tools/workflows/update_workflows.py --check \
          .github/workflows/pester-selfhosted.yml \
          .github/workflows/fixture-drift.yml \
          .github/workflows/ci-orchestrated.yml \
          .github/workflows/pester-integration-on-label.yml \
          .github/workflows/smoke.yml \
          .github/workflows/compare-artifacts.yml

    - name: Lint loop determinism (notice only on non-main)
      if: github.ref_name != 'main'
      shell: pwsh
      run: |
        $paths = Get-ChildItem -Path .github/workflows -Filter *.yml | ForEach-Object { $_.FullName }
        if ($paths) { pwsh -File tools/Lint-LoopDeterminism.Shim.ps1 -PathsList ($paths -join ';') } else { Write-Host '::notice::No workflow files to lint.' }

    - name: Lint loop determinism (enforced on main)
      if: github.ref_name == 'main'
      shell: pwsh
      run: |
        $paths = Get-ChildItem -Path .github/workflows -Filter *.yml | ForEach-Object { $_.FullName }
        if ($paths) { pwsh -File tools/Lint-LoopDeterminism.Shim.ps1 -PathsList ($paths -join ';') -FailOnViolation } else { Write-Host '::notice::No workflow files to lint.' }

    - name: Local markdown link check (intra-repo)
      shell: pwsh
      run: |
        # Simple intra-repo link checker: scans markdown for (./...) links and verifies files exist.
        $ErrorActionPreference = 'Stop'
        $mdFiles = Get-ChildItem -Path . -Recurse -Include *.md -File |
          Where-Object {
            $path = $_.FullName -replace '\\','/'
            return $path -notmatch '/node_modules/'
          }
        $errors = @()
        foreach ($file in $mdFiles) {
          $text = Get-Content -LiteralPath $file.FullName -Raw
          $matches = [regex]::Matches($text, '\]\((\.\/?[^)#\s]+)\)')
          foreach ($m in $matches) {
            $rel = $m.Groups[1].Value
            if ($rel -like 'http*' -or $rel -like '#*') { continue }
            # Strip anchors like file.md#section
            $pathOnly = $rel.Split('#')[0]
            $target = Join-Path $file.DirectoryName $pathOnly
            if (-not (Test-Path -LiteralPath $target)) {
              $errors += "[$($file.FullName)] broken link -> $rel (resolved: $target)"
            }
          }
        }
        if ($errors.Count -gt 0) {
          Write-Host 'Broken intra-repo links detected:'
          $errors | ForEach-Object { Write-Host " - $_" }
          exit 2
        } else {
          Write-Host 'Intra-repo markdown links OK.'
        }

    - name: Append docs pointers
      if: always()
      shell: pwsh
      run: |
        if ($env:GITHUB_STEP_SUMMARY) {
          $lines = @('### Docs Pointers','')
          $lines += '- Fixture Drift: ./docs/FIXTURE_DRIFT.md'
          $lines -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
        }

    - name: Labels sync summary (develop only)
      if: github.ref_name == 'develop'
      shell: pwsh
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        $ErrorActionPreference = 'Continue'
        $labelsFile = '.github/labels.yml'
        if (-not (Test-Path -LiteralPath $labelsFile)) { Write-Host '::notice::.github/labels.yml not found'; exit 0 }
        try {
          $yaml = Get-Content -LiteralPath $labelsFile -Raw
          # crude parse: entries like '- name: xyz' on their own line
          $names = @([regex]::Matches($yaml,'(?m)^\s*-\s*name:\s*(.+?)\s*$') | ForEach-Object { $_.Groups[1].Value.Trim() })
        } catch { $names = @() }
        $api = "https://api.github.com/repos/${{ github.repository }}/labels?per_page=100"
        $hdr = @{ Authorization = "token $env:GITHUB_TOKEN"; Accept='application/vnd.github+json'; 'X-GitHub-Api-Version'='2022-11-28' }
        $existing = @()
        try { $resp = Invoke-RestMethod -Method Get -Uri $api -Headers $hdr; $existing = @($resp | ForEach-Object { $_.name }) } catch {}
        $missing = @($names | Where-Object { $_ -and ($existing -notcontains $_) })
        if ($env:GITHUB_STEP_SUMMARY) {
          $lines = @('### Labels Sync (notice)','')
          $lines += ('- Defined in labels.yml: {0}' -f ($names.Count))
          $lines += ('- Repo labels: {0}' -f ($existing.Count))
          if ($missing.Count -gt 0) {
            $lines += '- Missing:'
            foreach ($m in $missing) { $lines += ('  - ' + $m) }
          } else {
            $lines += '- Missing: none'
          }
          $lines -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
        }

    - name: Labels sync enforcement (main)
      if: github.ref_name == 'main'
      shell: pwsh
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        $ErrorActionPreference = 'Stop'
        $labelsFile = '.github/labels.yml'
        if (-not (Test-Path -LiteralPath $labelsFile)) { Write-Error '.github/labels.yml not found'; exit 2 }
        $yaml = Get-Content -LiteralPath $labelsFile -Raw
        $names = @([regex]::Matches($yaml,'(?m)^\s*-\s*name:\s*(.+?)\s*$') | ForEach-Object { $_.Groups[1].Value.Trim() })
        $api = "https://api.github.com/repos/${{ github.repository }}/labels?per_page=100"
        $hdr = @{ Authorization = "token $env:GITHUB_TOKEN"; Accept='application/vnd.github+json'; 'X-GitHub-Api-Version'='2022-11-28' }
        $resp = Invoke-RestMethod -Method Get -Uri $api -Headers $hdr
        $existing = @($resp | ForEach-Object { $_.name })
        $missing = @($names | Where-Object { $_ -and ($existing -notcontains $_) })
        if ($missing.Count -gt 0) {
          Write-Host 'Missing labels:'
          $missing | ForEach-Object { Write-Host (' - ' + $_) }
          Write-Error ('Labels sync check failed on main: {0} missing' -f $missing.Count)
          exit 2
        } else {
          Write-Host 'Labels OK on main.'
        }

    - name: Run markdownlint (non-blocking)
      run: |
        markdownlint "**/*.md" --ignore node_modules
      continue-on-error: true
    env:
      ACTIONLINT_VERSION: '${{ vars.ACTIONLINT_VERSION || ''1.7.7'' }}'
  fixtures:
    runs-on: [self-hosted, Windows, X64]
    env:
      FAIL_ON_NEW_STRUCTURAL: 'false' # toggle to 'true' to fail job on new structural fixture issues
      SUMMARY_VERBOSE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.summary-verbose || 'false' }}
    steps:
    - uses: actions/checkout@v5
    - name: Wire Probe (J1)
      if: '${{ vars.WIRE_PROBES != ''0'' }}'
      uses: ./.github/actions/wire-probe
      with:
        phase: J1
        results-dir: tests/results
    - name: Wire Probe (J2)
      if: '${{ vars.WIRE_PROBES != ''0'' }}'
      uses: ./.github/actions/wire-probe
      with:
        phase: J2
        results-dir: tests/results
    - name: Run fixture validator (JSON)
      shell: pwsh
      continue-on-error: true
      run: |
        $ErrorActionPreference = 'Stop'
        pwsh -File tools/Validate-Fixtures.ps1 -Json -MinBytes 32 > fixture-validation.json
        $exit = $LASTEXITCODE
        if ($exit -ne 0) { Write-Host "::warning::Fixture validator exit code: $exit (non-blocking)" }
        $data = Get-Content fixture-validation.json -Raw | ConvertFrom-Json
        if (-not $data.ok) { Write-Host 'Fixture validation issues detected. (Non-fatal: continuing for now)' }
    - name: Restore previous fixture validation snapshot (cache)
      id: restore_prev_fixture_validation
      uses: actions/cache/restore@v4
      with:
        path: fixture-validation-prev.json
        key: fixture-validation-${{ github.sha }}
        restore-keys: |
          fixture-validation-
    - name: Compute delta vs previous snapshot
      if: steps.restore_prev_fixture_validation.outputs.cache-hit == 'true'
      shell: pwsh
      run: |
        Write-Host 'Previous snapshot restored. Computing delta.'
        pwsh -File tools/Diff-FixtureValidationJson.ps1 -Baseline fixture-validation-prev.json -Current fixture-validation.json -FailOnNewStructuralIssue > fixture-validation-delta.json
        if ($LASTEXITCODE -eq 3) {
          Write-Host 'New structural fixture issues detected (delta willFail=true).'
          if ($env:FAIL_ON_NEW_STRUCTURAL -eq 'true') {
            Write-Error 'Failing job due to FAIL_ON_NEW_STRUCTURAL=true'
            exit 3
          } else {
            Write-Host 'FAIL_ON_NEW_STRUCTURAL=false -> continuing without failing.'
          }
        }
    - name: Validate delta JSON schema (basic)
      if: steps.restore_prev_fixture_validation.outputs.cache-hit == 'true' && hashFiles('fixture-validation-delta.json') != ''
      shell: pwsh
      run: |
        pwsh -File tools/Test-FixtureValidationDeltaSchema.ps1 -DeltaJsonPath fixture-validation-delta.json
    - name: Lite schema validate (delta)
      if: steps.restore_prev_fixture_validation.outputs.cache-hit == 'true' && hashFiles('fixture-validation-delta.json') != ''
      shell: pwsh
      run: |
        pwsh -File tools/Invoke-JsonSchemaLite.ps1 -JsonPath fixture-validation-delta.json -SchemaPath docs/schemas/fixture-validation-delta-v1.schema.json
    - name: Upload fixture validation delta JSON
      if: steps.restore_prev_fixture_validation.outputs.cache-hit == 'true' && hashFiles('fixture-validation-delta.json') != ''
      uses: actions/upload-artifact@v5
      with:
        name: validate-fixture-validation-delta-json
        path: fixture-validation-delta.json
    - name: Upload fixture validation JSON
      uses: actions/upload-artifact@v5
      with:
        name: validate-fixture-validation-json
        path: fixture-validation.json
    - name: Lite schema validate (snapshot)
      shell: pwsh
      continue-on-error: true
      run: |
        if (Test-Path fixture-validation.json) {
          try {
            pwsh -File tools/Invoke-JsonSchemaLite.ps1 -JsonPath fixture-validation.json -SchemaPath docs/schemas/fixture-manifest-v1.schema.json
            if ($LASTEXITCODE -ne 0) { Write-Host "::notice::Snapshot schema-lite returned $LASTEXITCODE (non-blocking)" }
          } catch { Write-Host '::notice::Snapshot schema-lite skipped or failed (non-fatal).' }
        }
    - name: Append fixture summary
      shell: pwsh
      run: pwsh -File tools/Write-FixtureValidationSummary.ps1 -ValidationJson fixture-validation.json -DeltaJson fixture-validation-delta.json
    - name: Write fixture summary file
      if: always()
      shell: pwsh
      run: pwsh -File tools/Write-FixtureValidationSummary.ps1 -ValidationJson fixture-validation.json -DeltaJson fixture-validation-delta.json -SummaryPath fixture-summary.md
    - name: Upload fixture summary artifact
      if: always() && hashFiles('fixture-summary.md') != ''
      uses: actions/upload-artifact@v5
      with:
        name: fixture-validation-summary
        path: fixture-summary.md
    - name: Save current snapshot to cache
      uses: actions/cache/save@v4
      with:
        path: fixture-validation.json
        key: fixture-validation-${{ github.sha }}
    - name: Copy snapshot for next run reference
      shell: pwsh
      run: Copy-Item -LiteralPath fixture-validation.json -Destination fixture-validation-prev.json -Force

    - name: Agent wait summary (notice-only)
      if: always()
      uses: ./.github/actions/agent-wait-post
      with:
        results-dir: tests/results
        fail-on-outside: 'false'
        upload-artifact: 'false'

  hook-parity:
    needs: lint
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
    - uses: actions/checkout@v5

    - uses: actions/setup-node@v5
      with:
        node-version: '20'

    - name: Install dependencies (no scripts)
      run: npm ci --ignore-scripts

    - name: Clean hook results directory
      shell: bash
      run: |
        rm -rf tests/results/_hooks
        mkdir -p tests/results/_hooks

    - name: Prepare staged fixture
      shell: bash
      run: |
        rm -rf tmp/hooks
        mkdir -p tmp/hooks
        cat <<'PS' > tmp/hooks/sample.ps1
        function Invoke-HookSample {
          param()
          Write-Output 'hook parity sample'
        }
        Invoke-HookSample
        PS
        git add tmp/hooks/sample.ps1

    - name: Prime actionlint binary
      shell: pwsh
      run: ./tools/PrePush-Checks.ps1

    - name: Hooks plane info
      run: node tools/npm/run-script.mjs hooks:plane

    - name: Hooks preflight
      run: node tools/npm/run-script.mjs hooks:preflight

    - name: Run multi-plane hook diff
      run: node tools/npm/run-script.mjs hooks:multi

    - name: Validate hook summary schema
      run: node tools/npm/run-script.mjs hooks:schema

    - name: Upload hook parity summaries
      if: always()
      uses: actions/upload-artifact@v5
      with:
        name: hook-parity-${{ matrix.os }}
        path: tests/results/_hooks/*.json

    - name: Reset staged files
      if: always()
      shell: bash
      run: |
        git reset --hard
        rm -rf tmp/hooks

  semver:
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-node@v5
        with:
          node-version: '20'
      - name: Install dependencies (no scripts)
        run: npm ci --ignore-scripts
      - name: SemVer check
        run: node tools/npm/run-script.mjs semver:check

  release-branch:
    if: startsWith(github.head_ref, 'release/')
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v5
        with:
          node-version: '20'
      - name: Install dependencies (no scripts)
        run: npm ci --ignore-scripts
      - name: Verify release branch
        env:
          GITHUB_HEAD_REF: ${{ github.head_ref }}
          RELEASE_VALIDATE_BASE: origin/develop
        run: node tools/priority/verify-release-branch.mjs

  feature-handoff:
    if: startsWith(github.head_ref, 'feature/')
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v5
        with:
          node-version: '20'
      - name: Install dependencies (no scripts)
        run: npm ci --ignore-scripts
      - name: Run priority handoff tests
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PRIORITY_HANDOFF_SKIP_POLICY: '1'
        run: node tools/npm/run-script.mjs priority:handoff-tests

  issue-snapshot:
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-node@v5
        with:
          node-version: '20'
      - name: Sync standing-priority snapshot
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          if [ -z "${GH_TOKEN:-${GITHUB_TOKEN:-}}" ]; then
            echo "::error::GH_TOKEN/GITHUB_TOKEN is required for priority:sync"
            exit 1
          fi
          node tools/npm/run-script.mjs priority:sync
      - name: Validate snapshot schema (best-effort)
        continue-on-error: true
        run: |
          node tools/npm/run-script.mjs priority:schema
      - name: Upload issue snapshot artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: standing-priority-snapshot
          path: |
            tests/results/_agent/issue/*.json
            tests/results/_agent/issue/*.digest

  session-index:
    needs: lint
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v5

    - name: Wire Probe (J1)
      if: '${{ vars.WIRE_PROBES != ''0'' }}'
      uses: ./.github/actions/wire-probe
      with:
        phase: J1
        results-dir: tests/results
    - name: Wire Probe (J2)
      if: '${{ vars.WIRE_PROBES != ''0'' }}'
      uses: ./.github/actions/wire-probe
      with:
        phase: J2
        results-dir: tests/results
    - name: Resolve Pester version
      id: resolve_pester
      shell: pwsh
      run: |
        $version = if ($env:PESTER_VERSION -and $env:PESTER_VERSION.Trim()) { $env:PESTER_VERSION } else { (./tools/Get-PesterVersion.ps1) }
        "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

    - name: Install Pester ${{ steps.resolve_pester.outputs.version }}
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        $pesterVersion = '${{ steps.resolve_pester.outputs.version }}'
        $installed = $false
        $galleryUri = 'https://www.powershellgallery.com/api/v2/'
        $installLegacy = {
          Install-Module -Name Pester -RequiredVersion $pesterVersion -Force -Scope CurrentUser
        }
        try {
          &$installLegacy
          $installed = $true
        } catch {
          Write-Host ("::notice::Install-Module first attempt failed: {0}" -f $_.Exception.Message)
          try {
            Register-PSRepository -Default -ErrorAction Stop
          } catch {
            Write-Host ("::warning::Register-PSRepository -Default failed: {0}" -f $_.Exception.Message)
          }
          try {
            &$installLegacy
            $installed = $true
          } catch {
            Write-Host ("::notice::Install-Module retry failed: {0}" -f $_.Exception.Message)
            Write-Host "::notice::Falling back to PSResourceGet for Pester installation."
            try {
              Register-PSResourceRepository -Name PSGallery -Uri $galleryUri -Trusted -ErrorAction SilentlyContinue
            } catch {
              Write-Host ("::warning::Register-PSResourceRepository fallback failed: {0}" -f $_.Exception.Message)
            }
            $attempts = 0
            $maxAttempts = 5
            while (-not $installed -and $attempts -lt $maxAttempts) {
              try {
                Install-PSResource -Name Pester -Version $pesterVersion -Scope CurrentUser -TrustRepository -Repository PSGallery
                $installed = $true
              } catch {
                $attempts++
                if ($attempts -ge $maxAttempts) {
                  Write-Host ("::warning::Install-PSResource exhausted attempts ({0}): {1}" -f $attempts, $_.Exception.Message)
                  break
                }
                Write-Host ("::notice::Install-PSResource attempt {0} failed: {1}" -f $attempts, $_.Exception.Message)
                $delay = [math]::Min(30, [math]::Pow(2, $attempts))
                Start-Sleep -Seconds $delay
              }
            }
            if (-not $installed) {
              Write-Host "::notice::Attempting manual PSGallery download fallback for Pester."
              $downloadRoot = Join-Path $env:RUNNER_TEMP 'pester-download'
              New-Item -ItemType Directory -Path $downloadRoot -Force | Out-Null
              $packagePath = Join-Path $downloadRoot ("Pester.{0}.nupkg" -f $pesterVersion)
              $downloadEndpoints = @(
                @{ Uri = ('{0}/package/Pester/{1}' -f $galleryUri.TrimEnd('/'), $pesterVersion); SkipCert = $false },
                @{ Uri = ('https://psg-prod-eastus.azureedge.net/packages/pester.{0}.nupkg' -f $pesterVersion.ToLowerInvariant()); SkipCert = $true }
              )
              $downloaded = $false
              foreach ($endpoint in $downloadEndpoints) {
                if ($downloaded) { break }
                for ($i = 1; $i -le 3 -and -not $downloaded; $i++) {
                  try {
                    $commonArgs = @{
                      Uri              = $endpoint.Uri
                      OutFile          = $packagePath
                      UseBasicParsing  = $true
                      ErrorAction      = 'Stop'
                    }
                    if ($endpoint.SkipCert) {
                      Invoke-WebRequest @commonArgs -SkipCertificateCheck
                    } else {
                      Invoke-WebRequest @commonArgs
                    }
                    $downloaded = $true
                  } catch {
                    if ($i -ge 3) {
                      Write-Host ("::warning::Manual download attempt {0} ({1}) failed: {2}" -f $i, $endpoint.Uri, $_.Exception.Message)
                    } else {
                      Write-Host ("::notice::Manual download attempt {0} ({1}) failed: {2}" -f $i, $endpoint.Uri, $_.Exception.Message)
                      Start-Sleep -Seconds ([math]::Min(30, [math]::Pow(2, $i)))
                    }
                  }
                }
              }
              if ($downloaded -and (Test-Path -LiteralPath $packagePath)) {
                $modulePaths = $env:PSModulePath -split [System.IO.Path]::PathSeparator
                $destRoot = $modulePaths | Where-Object { $_ -and $_.Trim() } | Where-Object { $_ -like '*Modules*' } | Select-Object -First 1
                if (-not $destRoot) {
                  $destRoot = Join-Path ([Environment]::GetFolderPath('UserProfile')) '.local/share/powershell/Modules'
                }
                $destPath = Join-Path $destRoot ('Pester/{0}' -f $pesterVersion)
                New-Item -ItemType Directory -Force -Path $destPath | Out-Null
                Expand-Archive -Path $packagePath -DestinationPath $destPath -Force
                $installed = $true
              } else {
                Write-Host "::warning::Manual PSGallery download fallback failed."
              }
            }
          }
        }
        if (-not $installed) {
          throw 'Failed to install Pester from PSGallery.'
        }
        $repo = Get-PSRepository -Name PSGallery -ErrorAction SilentlyContinue
        if ($repo -and $repo.InstallationPolicy -ne 'Trusted') {
          try {
            Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          } catch {
            Write-Host ("::notice::Unable to set PSGallery installation policy to Trusted: {0}" -f $_.Exception.Message)
          }
        }

    - name: Run dispatcher smoke to produce session index
      shell: pwsh
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        $res = Join-Path $env:RUNNER_TEMP 'sessionindex'
        New-Item -ItemType Directory -Force -Path $res | Out-Null
        ./tools/Quick-DispatcherSmoke.ps1 -ResultsPath $res -PreferWorkspace
        $contexts = @(
          'Validate / lint'
          'Validate / fixtures'
          'Validate / session-index'
        )
        $bpScript = Join-Path (Get-Location) 'tools/Update-SessionIndexBranchProtection.ps1'
        $bpApiScript = Join-Path (Get-Location) 'tools/Get-BranchProtectionRequiredChecks.ps1'
        $branchName = '${{ github.base_ref || github.ref_name }}'
        $repoParts = '${{ github.repository }}'.Split('/')
        $bpResult = & $bpApiScript -Owner $repoParts[0] -Repository $repoParts[1] -Branch $branchName -Token $env:GITHUB_TOKEN
        $updateArgs = @{
          ResultsDir        = $res
          PolicyPath        = 'tools/policy/branch-required-checks.json'
          Branch            = $branchName
          ProducedContexts  = $contexts
        }
        if ($bpResult.status) { $updateArgs['ActualStatus'] = $bpResult.status }
        if ($bpResult.contexts) { $updateArgs['ActualContexts'] = @($bpResult.contexts) }
        if ($bpResult.notes) { $updateArgs['AdditionalNotes'] = @($bpResult.notes) }
        & $bpScript @updateArgs

    - name: Validate session index schema (schema-lite)
      shell: pwsh
      run: |
        $json = Join-Path $env:RUNNER_TEMP 'sessionindex' 'session-index.json'
        if (-not (Test-Path $json)) { Write-Error "session-index.json not found at $json"; exit 2 }
        pwsh -File tools/Invoke-JsonSchemaLite.ps1 -JsonPath $json -SchemaPath docs/schemas/session-index-v1.schema.json

    - name: Upload session index artifact
      if: always()
      uses: actions/upload-artifact@v5
      with:
        name: validate-session-index
        path: ${{ runner.temp }}/sessionindex/session-index.json
        if-no-files-found: warn

  icon-editor-gate:
    needs: [smoke-gate, lint]
    if: needs.smoke-gate.outputs.skip != 'true'
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.decision.outputs.proceed }}
      issue-number: ${{ steps.decision.outputs.issue }}
    steps:
      - name: Determine icon-editor CI eligibility
        id: decision
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const summary = [];
            const branch =
              context.payload.pull_request?.head.ref ??
              context.ref.replace('refs/heads/', '');
            const match = branch.match(/(?:^|\/)issue\/(\d+)/i);
            if (!match) {
              core.setOutput('proceed', 'false');
              summary.push(`Branch \`${branch}\` is not issue-scoped (missing \`issue/<number>\`). Skipping icon-editor build.`);
              core.info(summary.at(-1));
            } else {
              const issueNumber = parseInt(match[1], 10);
              core.setOutput('issue', issueNumber.toString());
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              const hasNoCI =
                issue.labels?.some((label) => label.name?.toLowerCase() === 'noci') ??
                false;
              if (issue.state !== 'open') {
                core.setOutput('proceed', 'false');
                summary.push(`Issue #${issueNumber} is ${issue.state}. Icon-editor build will be skipped.`);
                core.info(summary.at(-1));
              } else if (hasNoCI) {
                core.setOutput('proceed', 'false');
                summary.push(`#${issueNumber} carries a \`NoCI\` label. Icon-editor build will be skipped.`);
                core.info(summary.at(-1));
              } else {
                core.setOutput('proceed', 'true');
                summary.push(`Icon-editor CI enabled for issue #${issueNumber}.`);
                core.info(summary.at(-1));
              }
            }
            if (process.env.GITHUB_STEP_SUMMARY && summary.length) {
              const text = ['### Icon Editor CI Gate', '', ...summary, ''].join('\n');
              require('fs').appendFileSync(process.env.GITHUB_STEP_SUMMARY, text);
            }

  icon-editor-build:
    needs: [smoke-gate, lint, icon-editor-gate]
    if: >
      needs.smoke-gate.outputs.skip != 'true' &&
      needs.icon-editor-gate.outputs.proceed == 'true'
    environment:
      name: validation
    runs-on: [self-hosted, Windows, X64]
    defaults:
      run:
        shell: pwsh
    steps:
      - uses: actions/checkout@v5
      - name: Verify PowerShell host
        run: |
          Write-Host "pwsh path: $PSCommandPath"
          Write-Host "PowerShell version: $($PSVersionTable.PSVersion.ToString())"
      - name: Run icon-editor build
        id: build
        env:
          RESULTS_DIR: ${{ runner.temp }}\icon-editor
          ICON_EDITOR_ISSUE: ${{ needs.icon-editor-gate.outputs.issue-number }}
        run: |
          $results = $env:RESULTS_DIR
          New-Item -ItemType Directory -Force -Path $results | Out-Null

          $packageJson = Get-Content -LiteralPath 'package.json' -Raw | ConvertFrom-Json
          if (-not $packageJson.version) {
            throw 'package.json does not contain a version field.'
          }

          $versionParts = $packageJson.version.Split('.')
          if ($versionParts.Count -lt 3) {
            throw ("package.json version '{0}' is not in major.minor.patch format." -f $packageJson.version)
          }

          $buildNumberText = (& git rev-list --count HEAD).Trim()
          if (-not $buildNumberText) {
            throw 'Unable to compute git commit count for build number.'
          }

          $major = [int]$versionParts[0]
          $minor = [int]$versionParts[1]
          $patch = [int]$versionParts[2]
          $build = [int]$buildNumberText

          $metadata = [ordered]@{
            schema     = 'icon-editor/build-metadata@v1'
            issue      = $env:ICON_EDITOR_ISSUE
            runId      = $env:GITHUB_RUN_ID
            runAttempt = $env:GITHUB_RUN_ATTEMPT
            ref        = $env:GITHUB_REF
            commit     = $env:GITHUB_SHA
            timestamp  = (Get-Date).ToString('o')
            version    = [ordered]@{
              major = $major
              minor = $minor
              patch = $patch
              build = $build
              raw   = '{0}.{1}.{2}.{3}' -f $major, $minor, $patch, $build
              source = $packageJson.version
            }
          }
          if (-not $metadata.issue) { $metadata.issue = 'unknown' }
          if (-not $metadata.runId) { $metadata.runId = 'unknown' }
          if (-not $metadata.runAttempt) { $metadata.runAttempt = 'unknown' }
          if (-not $metadata.ref) { $metadata.ref = 'unknown' }
          if (-not $metadata.commit) { $metadata.commit = 'unknown' }

          $metadataPath = Join-Path $results 'metadata.json'
          $metadata | ConvertTo-Json -Depth 6 | Set-Content -LiteralPath $metadataPath -Encoding utf8

          pwsh -NoLogo -NoProfile -File tools/icon-editor/Invoke-IconEditorBuild.ps1 `
            -Major $major `
            -Minor $minor `
            -Patch $patch `
            -Build $build `
            -ResultsRoot $results `
            -RunUnitTests

          $manifestPath = Join-Path $results 'manifest.json'
          if (Test-Path -LiteralPath $manifestPath -PathType Leaf) {
            $manifest = Get-Content -LiteralPath $manifestPath -Raw | ConvertFrom-Json
            $artifactCount = ($manifest.artifacts | Measure-Object).Count
            $packageVersion = $metadata.version.raw
            if ($env:GITHUB_OUTPUT) {
              "package_version=$packageVersion" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
              "manifest_path=$manifestPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
              "metadata_path=$metadataPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            }
            $summary = @(
              '### Icon Editor Build',
              '',
              ("- Issue: #{0}" -f $metadata.issue),
              ("- Run: {0} (attempt {1})" -f $metadata.runId, $metadata.runAttempt),
              ("- Version: {0} (source {1}, build {2})" -f $packageVersion, $packageJson.version, $build),
              ("- Commit: {0}" -f $metadata.commit),
              ("- Packaging requested: {0}" -f $manifest.packagingRequested),
              ("- Dependencies toggled: {0}" -f $manifest.dependenciesApplied),
              ("- Unit tests run: {0}" -f $manifest.unitTestsRun),
              ("- Artifact count: {0}" -f $artifactCount),
              ("- Metadata: {0}" -f $metadataPath),
              ("- Manifest: {0}" -f $manifestPath),
              ''
            )
            if ($env:GITHUB_STEP_SUMMARY) {
              $summary -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            }
          } else {
            Write-Warning "manifest.json not found at $manifestPath"
          }
      - name: Upload icon-editor artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: icon-editor-build-${{ steps.build.outputs.package_version || 'unversioned' }}
          path: ${{ runner.temp }}\icon-editor
